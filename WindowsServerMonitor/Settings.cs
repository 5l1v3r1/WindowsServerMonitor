using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using BPUtil;
using Microsoft.Win32;

namespace WindowsServerMonitor
{
	public class Settings : SerializableObjectBase
	{
		public ushort webPort = 14448;
		public List<PerfMonSpec> monitors = new List<PerfMonSpec>();
		public void LoadDefaultMonitors()
		{
			monitors.Clear();
			monitors.Add(new PerfMonSpec("CPU %", "Processor", "% Processor Time", "_Total")
			{
				graphId = "g0"
			});
			monitors.Add(new PerfMonSpec("W3WP CPU %", "Process", "% Processor Time", null)
			{
				graphId = "g1",
				processFinder = new ProcessFinder("w3wp", "\\\\DefaultAppPool$")
			});
			monitors.Add(new PerfMonSpec("W3WP Working Set - Private (x10 MB)", "Process", "Working Set - Private", null)
			{
				graphId = "g1",
				scale = 0.0000001,
				processFinder = new ProcessFinder("w3wp", "\\\\DefaultAppPool$")
			});
			monitors.Add(new PerfMonSpec("Mbps Receive", "Network Interface", "Bytes Received/sec", "Local Area Connection")
			{
				graphId = "g2",
				scale = 0.000008
			});
			monitors.Add(new PerfMonSpec("Mbps Send", "Network Interface", "Bytes Sent/sec", "Local Area Connection")
			{
				graphId = "g2",
				scale = 0.000008
			});
		}
	}
	public class PerfMonSpec
	{
		/// <summary>
		/// The display name for this performance counter.  If null or whitespace, a name is autogenerated.
		/// </summary>
		public string label;
		/// <summary>
		/// The name of the Performance Counter category.
		/// </summary>
		public string categoryName;
		/// <summary>
		/// The name of the Performance Counter.
		/// </summary>
		public string counterName;
		/// <summary>
		/// The name of the Performance Counter instance. May be null or empty string.
		/// </summary>
		public string instanceName;
		/// <summary>
		/// The number of milliseconds to wait between data collection events.
		/// </summary>
		public int intervalMs = 1000;
		/// <summary>
		/// The number of data points to keep in memory.
		/// </summary>
		public int keepTimeMs = 86400000; // Default: 1 day
		public double scale = 1;
		/// <summary>
		/// An object to help "Process" category counters find their process.
		/// </summary>
		public ProcessFinder processFinder = null;
		/// <summary>
		/// (Optional) (NOT IMPLEMENTED) Unique ID of the graph to place this counter in.  If multiple IDs are provided, multiple graphs will be created.
		/// </summary>
		public string graphId = "";
		/// <summary>
		/// Gets the desired graph scale.
		/// </summary>
		/// <returns></returns>
		public double GetScale()
		{
			return Math.Max(scale, 0.000000000001);
		}
		/// <summary>
		/// Gets the desired interval in milliseconds, with a minimum value of 100.
		/// </summary>
		/// <returns></returns>
		public int GetIntervalMs()
		{
			return Math.Max(intervalMs, 100);
		}
		/// <summary>
		/// Gets the desired time duration of records to keep, clamped between 100 * interval and 1 week.
		/// </summary>
		/// <returns></returns>
		public int GetKeepTimeMs()
		{
			return Math.Min(Math.Max(keepTimeMs, GetIntervalMs() * 100), 604800000);
		}
		/// <summary>
		/// Gets the label for this counter.
		/// </summary>
		/// <returns></returns>
		public string GetLabel()
		{
			if (!string.IsNullOrWhiteSpace(label))
				return label;
			return categoryName + "/" + counterName + " (" + instanceName + ")";
		}
		/// <summary>
		/// Gets the instance name from data in the [processFinder] field, falling back to returning the [instanceName] field.  May be null.
		/// </summary>
		/// <returns></returns>
		public string GetInstanceName()
		{
			if (processFinder != null)
				return processFinder.GetProcessInstanceName();
			return instanceName;
		}

		public PerfMonSpec() { }
		public PerfMonSpec(string label, string categoryName, string counterName, string instanceName, int intervalMs = 1000, int keepTimeMs = 86400000, double scale = 1, ProcessFinder processFinder = null)
		{
			this.label = label;
			this.categoryName = categoryName;
			this.counterName = counterName;
			this.instanceName = instanceName;
			this.intervalMs = intervalMs;
			this.keepTimeMs = keepTimeMs;
			this.scale = scale;
			this.processFinder = processFinder;
		}
	}

	public class ProcessFinder
	{
		/// <summary>
		/// Name of process, e.g. "w3wp"
		/// </summary>
		public string name;
		/// <summary>
		/// (Optional) If not null or empty, a regular expression which must match the user name which started the process. e.g. "\\SYSTEM$"
		/// </summary>
		public string userNameRegex;
		public ProcessFinder() { }
		public ProcessFinder(string name, string userNameRegex)
		{
			this.name = name;
			this.userNameRegex = userNameRegex;
		}

		private object instanceNameLock = new object();
		private string instanceName = null;
		private Process process;
		public string GetProcessInstanceName()
		{
			PerfProcRegistryMod.DoMod();
			lock (instanceNameLock)
			{
				if (instanceName == null)
				{
					Process[] processes = Process.GetProcessesByName(name);
					if (!string.IsNullOrEmpty(userNameRegex))
					{
						processes = processes.Where(p =>
						{
							string owner = ProcessHelper.GetUserWhichOwnsProcess(p.Id);
							return Regex.IsMatch(owner, userNameRegex);
						}).ToArray();
					}
					if (processes.Length > 0)
					{
						process = processes[0];
						process.EnableRaisingEvents = true;
						process.Exited += Process_Exited;
						instanceName = Util.GetProcessInstanceName(process);
						Logger.Info("Process " + process.Id + " instance name is " + instanceName);
					}
				}
				return instanceName;
			}
		}

		private void Process_Exited(object sender, EventArgs e)
		{
			lock (instanceNameLock)
			{
				instanceName = null;
				if (sender != null && sender is Process)
					((Process)sender).Dispose();
			}
		}
	}
	/// <summary>
	/// Performs the registry modification described here: https://support.microsoft.com/en-us/help/281884/the-process-object-in-performance-monitor-can-display-process-ids-pids
	/// </summary>
	static class PerfProcRegistryMod
	{
		private static object ModLock = new object();
		private static bool ModDone = false;
		/// <summary>
		/// Sets the DWORD value "ProcessNameFormat" to 2 in "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PerfProc\Performance".  This method is designed to be efficient if called multiple times, only performing work if necessary.
		/// </summary>
		public static void DoMod()
		{
			if (!ModDone)
				lock (ModLock)
				{
					if (!ModDone)
					{
						ModDone = ReadModState();
						if (!ModDone)
							if (ApplyModState(true))
								ModDone = true;
					}
				}
		}
		/// <summary>
		/// Sets the DWORD value "ProcessNameFormat" to 1 in "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\PerfProc\Performance".  This method is designed to be efficient if called multiple times, only performing work if necessary.
		/// </summary>
		public static void UndoMod()
		{
			lock (ModLock)
			{
				ModDone = ReadModState();
				if (ModDone)
					if (ApplyModState(false))
						ModDone = false;
			}
		}

		private static bool ReadModState()
		{
			RegistryKey Performance = RegistryUtil.GetHKLMKey(@"SYSTEM\CurrentControlSet\Services\PerfProc\Performance");
			if (Performance == null)
				return false;
			if (!Performance.GetValueNames().Contains("ProcessNameFormat") || Performance.GetValueKind("ProcessNameFormat") != RegistryValueKind.DWord)
				return false;
			int ProcessNameFormat = (int)Performance.GetValue("ProcessNameFormat");
			return ProcessNameFormat == 2;
		}

		private static bool ApplyModState(bool enablePIDData)
		{
			RegistryKey Performance = RegistryUtil.HKLM.OpenSubKey(@"SYSTEM\CurrentControlSet\Services\PerfProc\Performance", true);
			if (Performance == null)
				return false;
			Performance.SetValue("ProcessNameFormat", enablePIDData ? 2 : 1, RegistryValueKind.DWord);
			return true;
		}
	}
}
